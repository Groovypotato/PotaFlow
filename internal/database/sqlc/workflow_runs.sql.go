// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workflow_runs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWorkflowRun = `-- name: CreateWorkflowRun :one
INSERT INTO workflow_runs (workflow_id, status, trigger_type, started_at)
VALUES ($1, $2, $3, $4)
RETURNING id::text, workflow_id::text, status, trigger_type, started_at, finished_at, created_at
`

type CreateWorkflowRunParams struct {
	WorkflowID  string             `json:"workflow_id"`
	Status      string             `json:"status"`
	TriggerType string             `json:"trigger_type"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
}

type CreateWorkflowRunRow struct {
	ID          string             `json:"id"`
	WorkflowID  string             `json:"workflow_id"`
	Status      string             `json:"status"`
	TriggerType string             `json:"trigger_type"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	FinishedAt  pgtype.Timestamptz `json:"finished_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateWorkflowRun(ctx context.Context, arg CreateWorkflowRunParams) (CreateWorkflowRunRow, error) {
	row := q.db.QueryRow(ctx, createWorkflowRun,
		arg.WorkflowID,
		arg.Status,
		arg.TriggerType,
		arg.StartedAt,
	)
	var i CreateWorkflowRunRow
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.Status,
		&i.TriggerType,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listPendingWorkflowRuns = `-- name: ListPendingWorkflowRuns :many
SELECT id::text, workflow_id::text, status, trigger_type, started_at, finished_at, created_at
FROM workflow_runs
WHERE status = 'pending'
ORDER BY created_at
LIMIT $1
`

type ListPendingWorkflowRunsRow struct {
	ID          string             `json:"id"`
	WorkflowID  string             `json:"workflow_id"`
	Status      string             `json:"status"`
	TriggerType string             `json:"trigger_type"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	FinishedAt  pgtype.Timestamptz `json:"finished_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListPendingWorkflowRuns(ctx context.Context, limit int32) ([]ListPendingWorkflowRunsRow, error) {
	rows, err := q.db.Query(ctx, listPendingWorkflowRuns, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingWorkflowRunsRow
	for rows.Next() {
		var i ListPendingWorkflowRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.Status,
			&i.TriggerType,
			&i.StartedAt,
			&i.FinishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowRunsByWorkflow = `-- name: ListWorkflowRunsByWorkflow :many
SELECT id::text, workflow_id::text, status, trigger_type, started_at, finished_at, created_at
FROM workflow_runs
WHERE workflow_id = $1
ORDER BY created_at DESC
`

type ListWorkflowRunsByWorkflowRow struct {
	ID          string             `json:"id"`
	WorkflowID  string             `json:"workflow_id"`
	Status      string             `json:"status"`
	TriggerType string             `json:"trigger_type"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	FinishedAt  pgtype.Timestamptz `json:"finished_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListWorkflowRunsByWorkflow(ctx context.Context, workflowID string) ([]ListWorkflowRunsByWorkflowRow, error) {
	rows, err := q.db.Query(ctx, listWorkflowRunsByWorkflow, workflowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkflowRunsByWorkflowRow
	for rows.Next() {
		var i ListWorkflowRunsByWorkflowRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.Status,
			&i.TriggerType,
			&i.StartedAt,
			&i.FinishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startWorkflowRun = `-- name: StartWorkflowRun :one
UPDATE workflow_runs
SET status = 'running', started_at = COALESCE(started_at, now())
WHERE id = $1
RETURNING id::text, workflow_id::text, status, trigger_type, started_at, finished_at, created_at
`

type StartWorkflowRunRow struct {
	ID          string             `json:"id"`
	WorkflowID  string             `json:"workflow_id"`
	Status      string             `json:"status"`
	TriggerType string             `json:"trigger_type"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	FinishedAt  pgtype.Timestamptz `json:"finished_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) StartWorkflowRun(ctx context.Context, id string) (StartWorkflowRunRow, error) {
	row := q.db.QueryRow(ctx, startWorkflowRun, id)
	var i StartWorkflowRunRow
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.Status,
		&i.TriggerType,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateWorkflowRunStatus = `-- name: UpdateWorkflowRunStatus :one
UPDATE workflow_runs
SET status = $2, finished_at = $3
WHERE id = $1
RETURNING id::text, workflow_id::text, status, trigger_type, started_at, finished_at, created_at
`

type UpdateWorkflowRunStatusParams struct {
	ID         string             `json:"id"`
	Status     string             `json:"status"`
	FinishedAt pgtype.Timestamptz `json:"finished_at"`
}

type UpdateWorkflowRunStatusRow struct {
	ID          string             `json:"id"`
	WorkflowID  string             `json:"workflow_id"`
	Status      string             `json:"status"`
	TriggerType string             `json:"trigger_type"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	FinishedAt  pgtype.Timestamptz `json:"finished_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) UpdateWorkflowRunStatus(ctx context.Context, arg UpdateWorkflowRunStatusParams) (UpdateWorkflowRunStatusRow, error) {
	row := q.db.QueryRow(ctx, updateWorkflowRunStatus, arg.ID, arg.Status, arg.FinishedAt)
	var i UpdateWorkflowRunStatusRow
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.Status,
		&i.TriggerType,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
	)
	return i, err
}
