// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: triggers.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTrigger = `-- name: CreateTrigger :one
INSERT INTO triggers (workflow_id, type, config)
VALUES ($1, $2, $3)
RETURNING id::text, workflow_id::text, type, config, created_at
`

type CreateTriggerParams struct {
	WorkflowID string `json:"workflow_id"`
	Type       string `json:"type"`
	Config     []byte `json:"config"`
}

type CreateTriggerRow struct {
	ID         string             `json:"id"`
	WorkflowID string             `json:"workflow_id"`
	Type       string             `json:"type"`
	Config     []byte             `json:"config"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateTrigger(ctx context.Context, arg CreateTriggerParams) (CreateTriggerRow, error) {
	row := q.db.QueryRow(ctx, createTrigger, arg.WorkflowID, arg.Type, arg.Config)
	var i CreateTriggerRow
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.Type,
		&i.Config,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTrigger = `-- name: DeleteTrigger :exec
DELETE FROM triggers WHERE id = $1 AND workflow_id = $2
`

type DeleteTriggerParams struct {
	ID         string `json:"id"`
	WorkflowID string `json:"workflow_id"`
}

func (q *Queries) DeleteTrigger(ctx context.Context, arg DeleteTriggerParams) error {
	_, err := q.db.Exec(ctx, deleteTrigger, arg.ID, arg.WorkflowID)
	return err
}

const deleteTriggersByWorkflow = `-- name: DeleteTriggersByWorkflow :exec
DELETE FROM triggers WHERE workflow_id = $1
`

func (q *Queries) DeleteTriggersByWorkflow(ctx context.Context, workflowID string) error {
	_, err := q.db.Exec(ctx, deleteTriggersByWorkflow, workflowID)
	return err
}

const getTrigger = `-- name: GetTrigger :one
SELECT id::text, workflow_id::text, type, config, created_at
FROM triggers
WHERE id = $1 AND workflow_id = $2
`

type GetTriggerParams struct {
	ID         string `json:"id"`
	WorkflowID string `json:"workflow_id"`
}

type GetTriggerRow struct {
	ID         string             `json:"id"`
	WorkflowID string             `json:"workflow_id"`
	Type       string             `json:"type"`
	Config     []byte             `json:"config"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetTrigger(ctx context.Context, arg GetTriggerParams) (GetTriggerRow, error) {
	row := q.db.QueryRow(ctx, getTrigger, arg.ID, arg.WorkflowID)
	var i GetTriggerRow
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.Type,
		&i.Config,
		&i.CreatedAt,
	)
	return i, err
}

const listTriggersByWorkflow = `-- name: ListTriggersByWorkflow :many
SELECT id::text, workflow_id::text, type, config, created_at
FROM triggers
WHERE workflow_id = $1
ORDER BY created_at
`

type ListTriggersByWorkflowRow struct {
	ID         string             `json:"id"`
	WorkflowID string             `json:"workflow_id"`
	Type       string             `json:"type"`
	Config     []byte             `json:"config"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListTriggersByWorkflow(ctx context.Context, workflowID string) ([]ListTriggersByWorkflowRow, error) {
	rows, err := q.db.Query(ctx, listTriggersByWorkflow, workflowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTriggersByWorkflowRow
	for rows.Next() {
		var i ListTriggersByWorkflowRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.Type,
			&i.Config,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTrigger = `-- name: UpdateTrigger :one
UPDATE triggers
SET type = $2, config = $3
WHERE id = $1 AND workflow_id = $4
RETURNING id::text, workflow_id::text, type, config, created_at
`

type UpdateTriggerParams struct {
	ID         string `json:"id"`
	Type       string `json:"type"`
	Config     []byte `json:"config"`
	WorkflowID string `json:"workflow_id"`
}

type UpdateTriggerRow struct {
	ID         string             `json:"id"`
	WorkflowID string             `json:"workflow_id"`
	Type       string             `json:"type"`
	Config     []byte             `json:"config"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) UpdateTrigger(ctx context.Context, arg UpdateTriggerParams) (UpdateTriggerRow, error) {
	row := q.db.QueryRow(ctx, updateTrigger,
		arg.ID,
		arg.Type,
		arg.Config,
		arg.WorkflowID,
	)
	var i UpdateTriggerRow
	err := row.Scan(
		&i.ID,
		&i.WorkflowID,
		&i.Type,
		&i.Config,
		&i.CreatedAt,
	)
	return i, err
}
